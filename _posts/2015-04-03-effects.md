---
published: false
---

A pure function looks the same in almost any programming language. Where today's programming languages differ is in their handling of *effects*: the parts of the program that consist of something other than just substituting a function call with its return value.

[There is an equivalence](http://conal.net/blog/posts/the-c-language-is-purely-functional) between these things: any effect can be captured in a value that "lazily" represents performing that effect, and any manipulation of values could be modelled as an effect. [Assembly language](http://wall.org/~lewis/2013/10/15/asm-monad.html) (or rather machine code) is, paradoxically, the most extreme example of both: a machine-code program consists entirely of effects, because there's not even anywhere to put a value. But equivalently, a machine-code program is a value in the most obvious possible way: it's nothing but a sequence of bytes. Modern languagues make more finer-grained distinctions; in Haskell-style functional languages it's common to have a value (e.g. `GenerateRandomNumber`) that's "interpreted" first in some specific context (e.g. `Rng[Int]`), then in a more general context (e.g. `IO[Int]`), with several layers before we finally reach the stage of a general effect.

To talk of "effects" is inherently to adopt a certain perspective on these things: that they do have something in common and can be treated similarly; in a sense I'm already assuming the Haskell worldview, and the biases that come with it. But hopefully this is enlightening for programmers of other schools, and will maybe shed some new light on certain language design decisions. Unsurprisingly, different programming languages take different approaches to managing effects. What's more interesting is when the same language adopts quite different attitudes to two effects that seem to me quite similar.

Mostly I’ll use Java, Python and Scala as examples, because they’re the languages I’m most familiar with. When I’m aware of a language with a distinctive position on some area, I’ll mention it. Apologies if I misunderstand a feature of a less familiar language.

Compiling this list of examples, a few axes emerged:

 * How an effect appears in the source code. Some effects are *implicit*, some are *concise* and some are *verbose*.
 
 
A few examples of what I’m talking about. 
##Memory management
Magic: Java, Python, Scala. Most languages these days have automatic garbage collection. Most - but by no means all - of the time, performance is acceptable. Any function might allocate or free memory.
Manual, cumbersome: C. Full control but the programmer is responsible for ensuring that malloc/free match up.
Manual, moderate: C++ using stack-allocated objects, smart pointers and so forth. It’s up to the programmer to use these features, but if used correctly they provide correctness guarantees. RAII means memory and non-memory resources can be managed in the same way (so e.g. templates can be polymorphic in what kind of resource they’re using). Dedicated language constructs - pure stack-allocation/RAII (i.e. no shared objects) would be in the elegant category, but probably too hard to use in pratical programs.
Manual, moderate-elegant: Rust. Automatic checking of object lifecycles; safety is guaranteed unless explicit escape hatches are used. I’m not clear on exactly how “lifecycle-polymorphic” functions can be - potentially this belongs in the elegant category.
##Non-memory resources
Magic: Go with “dispose” - I’m not clear on how exactly this works. Python using destructors - since Python is reference counted it has deterministic-ish destruction, so one can write reasonably safe code that relies on object destruction to free resources. Any function might invisibly create or dispose of a resource.
Manual, cumbersome: Java <=6 - full control but the programmer is responsible for closing files etc. 
Manual, moderate: Python using “with”. Up to the programmer to use this feature, but if used then it works correctly. Dedicated language construct
Manual, moderate-elegant: Java 7+ using try-with-resources; as Python but the language will warn/error if an AutoCloseable is used in an unsafe way. Would be elegant if it didn’t need a dedicated language construct.
Scala with scala-arm: As Python but without a special construct, uses ordinary values and for/yield, so interoperates with generics. Would be elegant if it were automatically checked.
##Error handling
Magic: Python, Java using unchecked exceptions. Any function might throw or catch.
Manual, cumbersome: C. Programmer must explicitly handle errors, with little language-level support.
Manual, moderate-cumbersome: Go. As C but with some checking via the “res, err = …” syntax.
Manual, moderate: Java using checked exceptions. Correctness guaranteed, but requires a dedicated, non-polymorphic language construct.
Manual, moderate-elegant: Rust. Uses ordinary values and provides some degree of abstraction, but not fully polymorphic as the language lacks higher-kinded types.
Scala using \/ or Either. Uses ordinary values and for/yield, interoperable with generics. Mostly checked, but functions can also throw exceptions.
##File I/O
Magic: Java, Python, mainstream Scala. Any function might read or write files.
Manual, moderate-elegant: Scala using IO. Ordinary values and for/yield, interoperable with generics. Only checked when using functions that use it.
Manual, elegant: Haskell. Uses ordinary values, uses general constructs (Monad) that can be abstracted over, checked.
##Database Access
Magic: Traditional Java, Python, mainstream Scala. Any function might access a database. This classification doesn't really distinguish between the actual API (the JDBC API is far more cumbersome than e.g. SQLAlchemy), we're purely talking about effect-tracking here.
Manual, moderate: JPA / Hibernate. Uses annotations, which are concise but hard to abstract over and not refactor-safe. JPA relies on programmer to get transaction boundaries correct. Can be difficult in the presence of async or (to a lesser extent) exceptions.
Manual, elegant: Doobie - ordinary values, general constructs (Monad), inherently safe. (But I actually use Hibernate, as I find the conciseness of an ORM API is worth the safety cost).
##Async
##Audit logging
##Custom constructs
It’s inherently impossible for these to be magic.
Manual, cumbersome: most languages
##Redefining language syntax
#Thoughts
Actually two classifications: safety and consistency.

In the light of this, otherwise paradoxical decisions start to make sense. Java unchecked exceptions. (What does quasar do about exceptions that were thrown on a different thread?)

The biggest divide between contemporary programming languages is what’s allowed to happen "by magic". Magic is the programmer’s greatest foe, as it makes reasoning difficult or impossible. At the same time, some things have to be magic - reasoning about assembly code is just as hard as reasoning about poorly-factored metaclass-heavy Python.

As programming techniques improve, it becomes practical to explicitly manage things that previously had to be left to magic. At the same time, as language runtimes improve, it becomes more acceptable to leave things to magic.