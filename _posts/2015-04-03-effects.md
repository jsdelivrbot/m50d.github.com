---
published: false
---

A pure function looks the same in almost any programming language. Where today's programming languages differ is in their handling of *effects*: the parts of the program that consist of something other than just substituting a function call with its return value.

[There is an equivalence](http://conal.net/blog/posts/the-c-language-is-purely-functional) between these things: any effect can be captured in a value that "lazily" represents performing that effect, and any manipulation of values could be modelled as an effect. [Assembly language](http://wall.org/~lewis/2013/10/15/asm-monad.html) (or rather machine code) is, paradoxically, the most extreme example of both: a machine-code program consists entirely of effects, because there's not even anywhere to put a value. But equivalently, a machine-code program is a value in the most obvious possible way: it's nothing but a sequence of bytes. Modern languagues make more finer-grained distinctions; in Haskell-style functional languages it's common to have a value (e.g. `GenerateRandomNumber`) that's "interpreted" first in some specific context (e.g. `Rng[Int]`), then in a more general context (e.g. `IO[Int]`), with several layers before we finally reach the stage of a general effect.

To talk of "effects" is inherently to adopt a certain perspective on these things: that they do have something in common and can be treated similarly; in a sense I'm already assuming the Haskell worldview, and the biases that come with it. But hopefully this is enlightening for programmers of other schools, and will maybe shed some new light on certain language design decisions. Unsurprisingly, different programming languages take different approaches to managing effects. What's more interesting is when the same language adopts quite different attitudes to two effects that seem to me quite similar.

Mostly I’ll use Java, Python and Scala as examples, because they’re the languages I’m most familiar with. When I’m aware of a language with a distinctive position on some area, I’ll mention it. Apologies if I misunderstand a feature of a less familiar language.

Compiling this list of examples, a few axes emerged:

 * How an effect appears locally in the source code. Some effects are *magic* (that is, completely invisible) - the language simply manages that effect for you (so it will almost always also be implicit and safe). Some are *concise* and some are *verbose*.
 * How an effect appears more globally, from the function that calls the function in which the effect occurs. Some are *implicit* - a call to a function that performs that effect looks like any other function call. Some are *[special-cased](http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)* - functions with this effect must be handled differently from other functions, perhaps with language support or perhaps not. And some are *generic* - the effect is visible in the function call, but "effect-ness" can be abstracted over in the lanugage.
 * Whether the use of the effect is *safe* - the language enforces that the effect is handled correctly - or *unsafe* - it's up to the programmer to do that. I also found a distinct class of *semi-safe* effect handling, where there are constructs and simple rules that can be followed to ensure the effect is handled safely, but the language also permits invoking the effect unsafely (perhaps e.g. in legacy libraries).
 
#The examples
##Memory management
Java, Python, Scala: magic, implicit, safe. Most languages these days have automatic garbage collection
C: verbose, implicit, unsafe. C is the canonical example of a language with manual memory management: the programmer explicitly calls `malloc` and `free`, and is responsible for ensuring they're called correctly. Allocation and ownership are implicit beyond function scope: the only way to know whether a function will allocate memory for new data structures, or free that of existing ones, is with out-of-band information like comments.
C++: semi-concise, semi-generic, semi-safe. C++ can often feel like several languages at once (and so some now-common constructs are more verbose than they should be), but provided you use the right constructs (smart pointers, stack allocation with RAII) and follow a few rules then memory safety is enforced. How memory management appears globally is an interesting mix: memory management information is sometimes visible in a function definition (smart pointers, references) but not always. Abstracting memory management generically is interesting: in theory RAII means memory and non-memory resources can be managed in the same way (so e.g. templates can be polymorphic in what kind of resource they’re using), and templates can handle smart pointers or in theory even abstract over reference-ness. But I've seen limited use of these techniques in practice, in part because of the complexity of the template system.
Rust: concise, ???, safe. Rust's big selling point is that memory is manually managed, but safety is enforced (via the borrow checker), with the lifecycle of any function parameter visible in the function signature. I’m not clear on exactly how “lifecycle-polymorphic” functions can be - Rust doesn't have the abstractions you need to treat effects completely generically (i.e. higher-kinded types), but some level of abstraction over borrowed vs. owned vs. shared resources might be possible.
##Non-memory resources
Java <=6, Python <=2.4 using manual resources: verbose, implicit, unsafe. The programmer must explicitly free resources, and it usually requires a  `try`/`finally` block to do correctly.
Python <= 2.4 using destructors: magic, implicit, safe-ish. Python uses reference counting so has deterministic(ish) destruction, so it's possible to rely on object destructors to free resources (but at the risk of turning relatively benign memory leaks into more perilous resource leaks). I've even seen code that does this in early Java, but garbage collection makes it very unsafe: it's very possible to e.g. hit the OS file handle limit because your program never runs out of memory so never closes its files.
Python 2.5+ using `with` statements: concise, ???, semi-safe. Use a specific statement to give a resource block scope, safely, but relies on the programmer using that statement. Resources can't cleanly be passed across function boundaries - have to belong to a particular block.
Java 7+ using try-with-resources: concise, ???, safe. As Python, but the compiler will warn if the programmer forgets to use the statement with an `AutoCloseable` object.
Scala using scala-arm: concise, generic, semi-safe. The `Resource` abstraction makes it possible to pass a resource safely across function boundaries, and since it's an ordinary parameterized type we can abstract over it like any other effect. But as in the Python case, the user has to explicitly call `managed` on their resources.
C++ using RAII: Concise, implicit, safe. In C++ resources are usually managed via object construction and destruction; since object lifecycles are already managed carefully for the sake of memory management, we get management of other resources "for free".
Go with “dispose”: concise, ???, ??? - I’ve heard extreme claims about how nice this is. Must investigate further.
##Error handling
Java using checked exceptions: verbose, special-cased, safe. Java enforces that exceptions are caught or propagated explicitly at the language level. Exceptions are distinct from the rest of the type sysetm and it's impossible to abstract over whether a function throws. Handling the possibilty of error in a single function call requires a slightly clunky `try`-`catch` block.
Python, Java using unchecked exceptions, Scala or C++ using exceptions: concise, implicit, unsafe. Any function might throw, and exceptions might not be caught.
Scala using `Either` or `\/`: concise, generic, semi-safe. Possible-errors are an ordinary paramaterized type we can abstract over like any other effect, but the user must ensure their code returns errors rather than throwing (and use the `catching` construct to wrap legacy libraries).
C using error codes: verbose, special-cased, unsafe (though gcc does have  `warn_unused_result`). Error codes are passed as values of the same type as the actual value, meaning the language can't enforce that they're checked correctly. Propagating errors usually requires manual code and can't be abstracted over since there is no standardization of what different error codes might mean.
Go: verbose, special-cased, safe. As C but the `res, err =` syntax enforces that errors are handled.
Rust: concise, semi-generic, safe. As Scala but this is a language built-in mechanism so there is no risk of legacy code throwing exceptions. Error-ness [can be sort of abstracted over via a macro](http://lucumr.pocoo.org/2014/11/6/error-handling-in-rust/), but the language lacks higher-kinded types so can't express fully effect-generic functions.
##File I/O
Java, Python, mainstream Scala: magic, implicit, safeish. In most languages any function might read or write files. Reading or writing files is usually inherently safe, but in the presence of multithreading it can require very careful manual steps to ensure correctness.
Scala using `IO`: concise, generic, semi-safe. Again this is using an ordinary value to encapsulate I/O, so we can abstract over it and any other effect. The language enforces that `IO` values are composed correctly, but the programmer needs to take care to wrap legacy library calls if they perform I/O.
Haskell: concise, generic, safe. As Scala but this is a built-in language feature so any library will be explicit about I/O.
##Random number generation
Interestingly, these are exactly as File I/O:
Java, Python, mainstream Scala: magic, implicit, safeish.
Scala using `Rng`: concise, generic, semi-safe.
Haskell: concise, generic, safe.
##Database Access
Java JDBC, Python mysql module: verbose, implicit, unsafe. Any function might access the database, and the programmer must manually manage transaction boundaries.
Magic: Traditional Java, Python, mainstream Scala. Any function might access a database. This classification doesn't really distinguish between the actual API (the JDBC API is far more cumbersome than e.g. SQLAlchemy), we're purely talking about effect-tracking here.
Manual, moderate: JPA / Hibernate. Uses annotations, which are concise but hard to abstract over and not refactor-safe. JPA relies on programmer to get transaction boundaries correct. Can be difficult in the presence of async or (to a lesser extent) exceptions.
Manual, elegant: Doobie - ordinary values, general constructs (Monad), inherently safe. (But I actually use Hibernate, as I find the conciseness of an ORM API is worth the safety cost).
##Async
##Audit logging
##Custom constructs
It’s inherently impossible for these to be magic.
Manual, cumbersome: most languages
##Redefining language syntax
#Thoughts

Java unchecked exceptions. (What does quasar do about exceptions that were thrown on a different thread?)

Magic, Haskell

Go errors are values vs implicit asyncness