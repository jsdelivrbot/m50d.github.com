---
published: false
---

Giles Bowkett has mastered opposition, but he's not yet ready for government. In [this post](http://gilesbowkett.blogspot.com.au/2014/09/why-scrum-should-basically-just-die-in.html) he tells us Scrum is "conceptually flawed", "bizarre", "condescending" and at best, a "dog-and-pony show". But his only positive prescription, other than "get better at hiring engineers" (gee, I'd never have thought to try that), is the folksy wisdom that we should "treat these workers as adults and trust them to do their jobs." You don't want to do that, and they don't want to do that either.

If you tear down Scrum and don't replace it with anything, your developers will refactor the same code as each other and spend days sorting out the merge. Then they'll find out that no-one actually wanted the feature they were working on anyway, and they've wasted the last few weeks. Then they'll realize they have no idea what they're doing, or what anyone else is doing, and that the company isn't making anything anyway because it never does the things that could make it money because noone tells the lowly developers what those things are. And then they'll quit.

Estimating and planning with stakeholders puts the business value front-and-center - and what the business values can often surprise you. I was once on a team that received a cake from another office expressing their heartfelt gratitude for a two-line change that, had we any idea of the value placed on it, we could have made at any point in the previous six months. They'd assumed it would be months of work, so they never considered it high-priority enough to ask for (we only found out about it at all thanks to a company-wide drinking event, but that's another story...).

Some developers know and understand the business, and they should be treasured. But even the best such developer is unlikely to understand a business role as well as someone dedicated to that role - jack of all trades and all that. Making effective use of dedicated developers will make hiring easier and your business more productive than if everyone has to be capable of wearing every hat (and that's not to say you shouldn't encourage growth in that direction). So you absolutely *should* assume that developers aren't business people - not because there's no such thing as a businessy developer, but because *your process needs to work for developers who aren't businessy*.

One thing your team of (potentially) nonbusinessy developers and nontechnical businesspeople sometimes needs to do is make decisions that have both technical and business consequences. And as any economist will tell you,the best way for people with different information to reach a consensus is an auction. "I want this feature." "Ok, it'll cost you this." "That's too much. What about if I remove this requirement?"

Numerical estimates immediately nudge the dialogue in a productive direction. It's the difference between "no, because" and "yes, if": telling the business side: "we can start on that, but it will take three developers and one sysadmin two weeks to do just requirements a) and c)" is infinitely more helpful than "are you insane? We'd have to refrobnicate the buzzwitzer and defrob the lillicator", which is an all-too-common response to feature requests. After all, occasionally it really is worth spending those two weeks - but that decision can only be made with the benefit of both people's knowledge. Simply allowing business to tell engineering what to do goes just as badly as having tech decide everything for themselves.

I've seen scrum estimation work - it's not perfect, but it's one of those "unless you have something better" things. At my first job we had a simple solution to disputes over estimates: it's called the "you do it then". In fact the planning meeting worked as an auction on a second level: developers who were the "low bidder" on a particular story, because they were more familiar with that area of the code or enjoyed that style of programming more, would generally take that story. If someone already had two weeks' worth of work, we felt free to ignore their lowball estimates.

Similarly, estimates are denominated in abstract points (rather than, say, man-days) precisely to prevent managers doing something silly with them. Evidently in some companies this is insufficient, but again: positive suggestions are constructive, just throwing the whole thing away isn't. And at some point you have to be the change you want to see in the world: if a manager says you can't leave yet because your velocity this week is too low, do what I do. Tell him to fuck off.

Scrum-style estimation is not just good for the company, it's good for developers too. The most vital part of job satisfaction is the feeling that one is doing something valuable, something that other people want. For an ivory-tower backend programmer like me, who spent today switching our monad stack so that other programmers would get better error messages, you can sometimes feel like a lighthouse keeper in the post-apocalypse, unsure whether the ships you're guarding are even out there any more. Business requirements can sometimes feel perverse - and sometimes that means you've misunderstood them, and sometimes it doesn't. A planning meeting where you can ask for clarification from the person who actually wants the feature is the easiest way I've found to set my mind at rest.

The rest of Bowkett's attack is focussed on standups - or rather, on standups where managers sat down. That's not even bathwater, that's, like, the mold that's grown in your bath. But Bowkett is still determined to throw the baby out with it. Never mind that you could, like, tell the manager to stand up. Or sit down yourself.

Async-only development by distributed teams may work in some cases, but to claim it as a panacea is... questionable, to say the least. Bowkett is right that open-source distributed development produces higher-quality code than most software projects. 

(And of course in sustainable development you have a backlog on day 1. Your development process needs to work when you have a backlog; that's what makes it sustainable. So why not use it all the time?)

((I'll admit that "sprint" is a super-dumb term though))