---
layout: default
published: false
title: Automated Releasing with Maven
---

One of the proofs that the software industry is still immature is how much effort is still duplicated. I've now worked the same job in three very different industries, and while there has been plenty of business-specific stuff, there are some things I've found myself writing again each time: a type-safe [Hibernate](http://www.hibernate.org) query language, a responsive AJAX layer for [Wicket](http://wicket.apache.org), and a release system for [Maven](http://maven.apache.org).

I've witnessed more hate for Maven than any other piece of software; in my view this couldn't be more wrong. Simply put, Maven is an *opinionated* build system; it forces your project to bend to meet its expectations, not the other way around. Many users respond by trying to fight Maven, and come out with either hundreds of lines of fragile XML that will break the first time they add another plugin, or give up and go back to ant. I'm not sure I've actually programmed in anything that qualifies as a "bondage and discipline language", but Maven seems to meet the spec.

It's wonderful. This program is on a mission to eliminate "snowflake" builds (like  [snowflake servers](http://server.dzone.com/articles/martin-fowler-snowflake) - I wish I could find the parody article claiming that devops was destroying years of craftmanship in hand-building servers). And within the Java world it's basically succeeded, meaning I or any vaguely competent Java developer can pick up a new project and *not have to think about* how it's built. Like with code formatting standards, the value is not that Maven's standards are particularly good - more important is that we have a standard and all our projects follow it.

With this in mind, the obviously correct way to create stable builds of a project is with Maven's "release" plugin. I feel this is something of a misnomer; in maven, the only way to depend on a specific revision of a module is to make a release of that module. So you should release anything you want to depend on, or any version that other people might want to depend on; if you're following an agile approach I'd say each "story" should be a release. My experience with automated releasing parallels my discovery of git, and realising that I could commit not just every few hours, but every few minutes. At my first job (MX Telecom, now OpenMarket) the version numbers were in the thousands.

Releasing at MX was synonymous with deployment; we didn't do full-on continuous deployment to the same extent as e.g. Etsy, but we did deploy several times a day - again, one release corresponded to one agile story, i.e. one customer-facing feature. The release process was a low-tech, but highly effective custom python script. (This was a hallmark of many things at MX - our programming language, database, RPC mechanism and deployment infrastructure were all hopelessly out of date by the standards of the HN crowd, but we used them effectively, kept everything simple, and the results were both technically impressive and highly profitable).

Perhaps ironically, despite being "bigger" deployment at last.fm was a far more manual process - I think I only deployed once or twice in my three months there. We were expected to do progressive, "canary" deploys, and there was a much stronger culture of real-time monitoring on our production systems. (That said, MX's monitoring was more than adequate; we achieved a level of reliability far greater than I've seen anywhere else, losing perhaps two messages in close to as many years).

In my current job the approach has been slightly different, partly because the product isn't live yet. There are two schools of thought on what this means, both driven by the need to avoid slowing down development with deployment concerns; either releasing isn't important yet, or it's more necessary than ever to be able to release cheaply with minimal manual intervention. By now you'll have guessed that I fall into the latter camp; tempting as it was to produce a similar python script, the allure of something more "standard" was strong. So we now have a sequence of [Jenkins](http://jenkins-ci.org) builds that perform releases on request and nightly; this includes deployment to an automated testing system, but not to live servers. I would prefer to be following MX's policy of "every change to trunk requires a release" (so that trunk is always guaranteed to be a build that has passed acceptance testing and been deployed to live), but this is a start (and the reason that wouldn't work is we have vertically segregated developers working on the same trunk - but that's a whole 'nother post).